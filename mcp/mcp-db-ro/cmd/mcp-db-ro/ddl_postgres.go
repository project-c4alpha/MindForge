package main

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
)

func (postgresDriver) GetDDL(ctx context.Context, db *sql.DB, ref TableRef, includeIndexes bool) (DDLResult, error) {
	oid, err := pgTableOID(ctx, db, ref.Schema, ref.Table)
	if err != nil {
		return DDLResult{}, err
	}

	columns, err := pgColumns(ctx, db, oid)
	if err != nil {
		return DDLResult{}, err
	}
	constraints, err := pgConstraints(ctx, db, oid)
	if err != nil {
		return DDLResult{}, err
	}

	var b strings.Builder
	fmt.Fprintf(&b, "CREATE TABLE %s.%s (\n", quoteIdentPG(ref.Schema), quoteIdentPG(ref.Table))
	for i, c := range columns {
		if i > 0 {
			b.WriteString(",\n")
		}
		b.WriteString("  ")
		b.WriteString(quoteIdentPG(c.Name))
		b.WriteString(" ")
		b.WriteString(c.Type)

		if c.Identity != "" {
			switch c.Identity {
			case "a":
				b.WriteString(" GENERATED ALWAYS AS IDENTITY")
			case "d":
				b.WriteString(" GENERATED BY DEFAULT AS IDENTITY")
			default:
				b.WriteString(" GENERATED AS IDENTITY")
			}
		} else if c.Default != "" {
			b.WriteString(" DEFAULT ")
			b.WriteString(c.Default)
		}

		if c.NotNull {
			b.WriteString(" NOT NULL")
		}
	}
	for _, con := range constraints {
		b.WriteString(",\n  CONSTRAINT ")
		b.WriteString(quoteIdentPG(con.Name))
		b.WriteString(" ")
		b.WriteString(con.Def)
	}
	b.WriteString("\n);\n")

	out := DDLResult{
		TableDDL:   b.String(),
		DriverKind: string(DriverPostgres),
	}

	if includeIndexes {
		indexes, err := pgIndexes(ctx, db, oid)
		if err != nil {
			return DDLResult{}, err
		}
		out.IndexDDLs = indexes
	}

	return out, nil
}

type pgColumn struct {
	Name     string
	Type     string
	NotNull  bool
	Default  string
	Identity string
}

type pgConstraint struct {
	Name string
	Def  string
}

func pgTableOID(ctx context.Context, db *sql.DB, schema, table string) (uint32, error) {
	var oid uint32
	err := db.QueryRowContext(ctx, `
SELECT c.oid
FROM pg_class c
JOIN pg_namespace ns ON ns.oid = c.relnamespace
WHERE ns.nspname = $1 AND c.relname = $2 AND c.relkind IN ('r','p')
LIMIT 1`, schema, table).Scan(&oid)
	if err != nil {
		if err == sql.ErrNoRows {
			return 0, fmt.Errorf("table not found: %s.%s", schema, table)
		}
		return 0, err
	}
	return oid, nil
}

func pgColumns(ctx context.Context, db *sql.DB, oid uint32) ([]pgColumn, error) {
	rows, err := db.QueryContext(ctx, `
SELECT
  a.attname AS column_name,
  pg_catalog.format_type(a.atttypid, a.atttypmod) AS data_type,
  a.attnotnull AS not_null,
  COALESCE(pg_get_expr(ad.adbin, ad.adrelid), '') AS column_default,
  COALESCE(a.attidentity, '') AS attidentity
FROM pg_attribute a
JOIN pg_class c ON c.oid = a.attrelid
LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid AND ad.adnum = a.attnum
WHERE a.attrelid = $1 AND a.attnum > 0 AND NOT a.attisdropped
ORDER BY a.attnum`, oid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []pgColumn
	for rows.Next() {
		var c pgColumn
		if err := rows.Scan(&c.Name, &c.Type, &c.NotNull, &c.Default, &c.Identity); err != nil {
			return nil, err
		}
		out = append(out, c)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return out, nil
}

func pgConstraints(ctx context.Context, db *sql.DB, oid uint32) ([]pgConstraint, error) {
	rows, err := db.QueryContext(ctx, `
SELECT conname, pg_get_constraintdef(oid, true) AS condef
FROM pg_constraint
WHERE conrelid = $1 AND contype IN ('p','u','c','f')
ORDER BY conname`, oid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []pgConstraint
	for rows.Next() {
		var c pgConstraint
		if err := rows.Scan(&c.Name, &c.Def); err != nil {
			return nil, err
		}
		out = append(out, c)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return out, nil
}

func pgIndexes(ctx context.Context, db *sql.DB, oid uint32) ([]string, error) {
	rows, err := db.QueryContext(ctx, `
SELECT pg_get_indexdef(i.indexrelid) AS indexdef
FROM pg_index i
JOIN pg_class ic ON ic.oid = i.indexrelid
WHERE i.indrelid = $1 AND NOT i.indisprimary
ORDER BY ic.relname`, oid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var out []string
	for rows.Next() {
		var def string
		if err := rows.Scan(&def); err != nil {
			return nil, err
		}
		def = strings.TrimSpace(def)
		if def == "" {
			continue
		}
		if !strings.HasSuffix(def, ";") {
			def += ";"
		}
		out = append(out, def)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return out, nil
}

func quoteIdentPG(s string) string {
	return `"` + strings.ReplaceAll(s, `"`, `""`) + `"`
}
